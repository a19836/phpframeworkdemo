a:1:{s:44:"FileSystemServiceCacheRelatedServicesHandler";a:2:{s:7:"methods";a:9:{s:31:"addServiceToRelatedKeysToDelete";a:20:{s:4:"name";s:31:"addServiceToRelatedKeysToDelete";s:16:"start_line_index";i:23;s:17:"start_token_index";i:84;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:464:"/*
	1. loop the $service_related_keys_to_delete array
	2. for each element get the related folder
		$dir_path = .../cache/.../select_item/PHP/__related/
	3. then call the getFilePathKey function to get the $file_path
	4. if the correspondent service does NOT exist yet, call the registerKey function and add a new record for the  in the service key.
	
	However only try to do this loop if the registrationStatus did NOT exceed the MAXIMUM_REGISTRATION_ATTEMPTS
	*/";}s:25:"start_comments_line_index";i:14;s:26:"start_comments_token_index";i:82;s:23:"end_comments_line_index";i:22;s:24:"end_comments_token_index";i:82;s:22:"start_args_token_index";i:89;s:20:"end_args_token_index";i:104;s:9:"arguments";a:4:{s:7:"$prefix";N;s:4:"$key";N;s:31:"$service_related_keys_to_delete";N;s:5:"$type";s:5:"false";}s:25:"start_brackets_line_index";i:23;s:26:"start_brackets_token_index";i:106;s:23:"end_brackets_line_index";i:64;s:24:"end_brackets_token_index";i:479;s:14:"end_line_index";i:64;s:15:"end_token_index";i:479;}s:6:"delete";a:20:{s:4:"name";s:6:"delete";s:16:"start_line_index";i:75;s:17:"start_token_index";i:483;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:191:"/*
	$prefix = select_item
	$key = select_item_id-1_mysql 
	$type = PHP
	$key_type = PREFIX
	$original_key = select_item_id-
	
	$dir_path = .../cache/..../select_item/PHP/__related/prefix/
	*/";}s:25:"start_comments_line_index";i:66;s:26:"start_comments_token_index";i:481;s:23:"end_comments_line_index";i:74;s:24:"end_comments_token_index";i:481;s:22:"start_args_token_index";i:488;s:20:"end_args_token_index";i:502;s:9:"arguments";a:5:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:9:"$key_type";N;s:13:"$original_key";N;}s:25:"start_brackets_line_index";i:75;s:26:"start_brackets_token_index";i:504;s:23:"end_brackets_line_index";i:79;s:24:"end_brackets_token_index";i:549;s:14:"end_line_index";i:79;s:15:"end_token_index";i:549;}s:25:"deleteRelatedServicesKeys";a:20:{s:4:"name";s:25:"deleteRelatedServicesKeys";s:16:"start_line_index";i:91;s:17:"start_token_index";i:553;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:548:"/*
	1. For each file inside of the $dir_path, cheks if it is a folder. If it is call the same function again, otherwise:
	2. gets the content of the file, unserialized it and loop the correspondent array.
	3. For each item:
		3.1 checks if the item "select_item_id-1_mysql" is IN each item, this is, checkIfKeyTypeMatchValue
		3.2 if it matches gets the item file path
		3.3  then delete the file for the item.
	
	 * TODO: create threads support. This means for each group of 5 files, launch a new thread and delete the correspondent services.
	 */";}s:25:"start_comments_line_index";i:81;s:26:"start_comments_token_index";i:551;s:23:"end_comments_line_index";i:90;s:24:"end_comments_token_index";i:551;s:22:"start_args_token_index";i:558;s:20:"end_args_token_index";i:572;s:9:"arguments";a:5:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:9:"$key_type";N;s:9:"$dir_path";N;}s:25:"start_brackets_line_index";i:91;s:26:"start_brackets_token_index";i:574;s:23:"end_brackets_line_index";i:127;s:24:"end_brackets_token_index";i:893;s:14:"end_line_index";i:127;s:15:"end_token_index";i:893;}s:14:"getFilePathKey";a:20:{s:4:"name";s:14:"getFilePathKey";s:16:"start_line_index";i:139;s:17:"start_token_index";i:897;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:453:"/*
	Based in a $dir_path, loops all the sub_files and for each,
		gets the content,
		unserialize the content
		and checks if the array already contains the $key item.
		If a file contains the key, return that file, otherwise returns an array with potential files where that $key can be inserted.
		
	However the files have a MAXIMUM_ITEMS_PER_FILE, which means that if a file already exceed that limit, the loop will try to find the next file.
	If 
	*/";}s:25:"start_comments_line_index";i:129;s:26:"start_comments_token_index";i:895;s:23:"end_comments_line_index";i:138;s:24:"end_comments_token_index";i:895;s:22:"start_args_token_index";i:904;s:20:"end_args_token_index";i:909;s:9:"arguments";a:2:{s:9:"$dir_path";N;s:4:"$key";N;}s:25:"start_brackets_line_index";i:139;s:26:"start_brackets_token_index";i:911;s:23:"end_brackets_line_index";i:170;s:24:"end_brackets_token_index";i:1186;s:14:"end_line_index";i:170;s:15:"end_token_index";i:1186;}s:11:"registerKey";a:20:{s:4:"name";s:11:"registerKey";s:16:"start_line_index";i:180;s:17:"start_token_index";i:1190;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:397:"/*
	Based in a list of files ($free_file_paths returned from the getFilePathKey function), loop this array and for each item:
		gets the content
		unserialize the content
		and if the array did NOT exceed the MAXIMUM_ITEMS_PER_FILE, add the $key to the array
		then save the array again to the file.
	If all the files already exceed the limit, creates a new file and adds the $key to the file.
	*/";}s:25:"start_comments_line_index";i:172;s:26:"start_comments_token_index";i:1188;s:23:"end_comments_line_index";i:179;s:24:"end_comments_token_index";i:1188;s:22:"start_args_token_index";i:1195;s:20:"end_args_token_index";i:1203;s:9:"arguments";a:3:{s:9:"$dir_path";N;s:4:"$key";N;s:16:"$free_file_paths";N;}s:25:"start_brackets_line_index";i:180;s:26:"start_brackets_token_index";i:1205;s:23:"end_brackets_line_index";i:264;s:24:"end_brackets_token_index";i:1787;s:14:"end_line_index";i:264;s:15:"end_token_index";i:1787;}s:22:"createServiceMainError";a:20:{s:4:"name";s:22:"createServiceMainError";s:16:"start_line_index";i:268;s:17:"start_token_index";i:1791;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:90:"/* ---------------------------------------- XX ---------------------------------------- */";}s:25:"start_comments_line_index";i:266;s:26:"start_comments_token_index";i:1789;s:23:"end_comments_line_index";i:266;s:24:"end_comments_token_index";i:1789;s:22:"start_args_token_index";i:1796;s:20:"end_args_token_index";i:1805;s:9:"arguments";a:2:{s:7:"$prefix";N;s:5:"$type";s:5:"false";}s:25:"start_brackets_line_index";i:268;s:26:"start_brackets_token_index";i:1807;s:23:"end_brackets_line_index";i:276;s:24:"end_brackets_token_index";i:1883;s:14:"end_line_index";i:276;s:15:"end_token_index";i:1883;}s:24:"setRegistrationKeyStatus";a:15:{s:4:"name";s:24:"setRegistrationKeyStatus";s:16:"start_line_index";i:278;s:17:"start_token_index";i:1885;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:1890;s:20:"end_args_token_index";i:1905;s:9:"arguments";a:4:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:13:"$error_exists";s:5:"false";}s:25:"start_brackets_line_index";i:278;s:26:"start_brackets_token_index";i:1907;s:23:"end_brackets_line_index";i:290;s:24:"end_brackets_token_index";i:2039;s:14:"end_line_index";i:290;s:15:"end_token_index";i:2039;}s:24:"getRegistrationKeyStatus";a:15:{s:4:"name";s:24:"getRegistrationKeyStatus";s:16:"start_line_index";i:292;s:17:"start_token_index";i:2041;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:2046;s:20:"end_args_token_index";i:2054;s:9:"arguments";a:3:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;}s:25:"start_brackets_line_index";i:292;s:26:"start_brackets_token_index";i:2056;s:23:"end_brackets_line_index";i:299;s:24:"end_brackets_token_index";i:2119;s:14:"end_line_index";i:299;s:15:"end_token_index";i:2119;}s:32:"getRegistrationKeyStatusFilePath";a:15:{s:4:"name";s:32:"getRegistrationKeyStatusFilePath";s:16:"start_line_index";i:301;s:17:"start_token_index";i:2121;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:2126;s:20:"end_args_token_index";i:2134;s:9:"arguments";a:3:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;}s:25:"start_brackets_line_index";i:301;s:26:"start_brackets_token_index";i:2136;s:23:"end_brackets_line_index";i:308;s:24:"end_brackets_token_index";i:2207;s:14:"end_line_index";i:308;s:15:"end_token_index";i:2207;}}s:5:"props";a:3:{s:29:"MAXIMUM_REGISTRATION_ATTEMPTS";a:16:{s:4:"name";s:29:"MAXIMUM_REGISTRATION_ATTEMPTS";s:4:"type";s:6:"public";s:5:"value";s:1:"5";s:8:"var_type";s:0:"";s:6:"static";b:0;s:8:"abstract";b:0;s:5:"const";b:1;s:16:"start_line_index";i:6;s:17:"start_token_index";i:29;s:14:"end_line_index";i:6;s:15:"end_token_index";i:36;s:8:"comments";a:1:{i:0;s:13:"/*protected*/";}s:25:"start_comments_line_index";i:6;s:26:"start_comments_token_index";i:27;s:23:"end_comments_line_index";i:6;s:24:"end_comments_token_index";i:27;}s:47:"RELATED_SERVICE_REGISTRATION_STATUS_FOLDER_NAME";a:16:{s:4:"name";s:47:"RELATED_SERVICE_REGISTRATION_STATUS_FOLDER_NAME";s:4:"type";s:6:"public";s:5:"value";s:10:""__status"";s:8:"var_type";s:6:"string";s:6:"static";b:0;s:8:"abstract";b:0;s:5:"const";b:1;s:16:"start_line_index";i:7;s:17:"start_token_index";i:40;s:14:"end_line_index";i:7;s:15:"end_token_index";i:47;s:8:"comments";a:1:{i:0;s:13:"/*protected*/";}s:25:"start_comments_line_index";i:7;s:26:"start_comments_token_index";i:38;s:23:"end_comments_line_index";i:7;s:24:"end_comments_token_index";i:38;}s:28:"SERVICE_MAIN_ERROR_FILE_NAME";a:16:{s:4:"name";s:28:"SERVICE_MAIN_ERROR_FILE_NAME";s:4:"type";s:6:"public";s:5:"value";s:9:""__error"";s:8:"var_type";s:6:"string";s:6:"static";b:0;s:8:"abstract";b:0;s:5:"const";b:1;s:16:"start_line_index";i:8;s:17:"start_token_index";i:51;s:14:"end_line_index";i:8;s:15:"end_token_index";i:58;s:8:"comments";a:1:{i:0;s:13:"/*protected*/";}s:25:"start_comments_line_index";i:8;s:26:"start_comments_token_index";i:49;s:23:"end_comments_line_index";i:8;s:24:"end_comments_token_index";i:49;}}}}
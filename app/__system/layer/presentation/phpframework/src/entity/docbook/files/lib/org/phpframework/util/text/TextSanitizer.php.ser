a:1:{s:13:"TextSanitizer";a:1:{s:7:"methods";a:22:{s:31:"convertBinaryCodeInTextToBase64";a:15:{s:4:"name";s:31:"convertBinaryCodeInTextToBase64";s:16:"start_line_index";i:4;s:17:"start_token_index";i:7;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:14;s:20:"end_args_token_index";i:16;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:4;s:26:"start_brackets_token_index";i:18;s:23:"end_brackets_line_index";i:46;s:24:"end_brackets_token_index";i:405;s:14:"end_line_index";i:46;s:15:"end_token_index";i:405;}s:16:"normalizeAccents";a:20:{s:4:"name";s:16:"normalizeAccents";s:16:"start_line_index";i:49;s:17:"start_token_index";i:409;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:71:"//copied from https://www.php.net/manual/pt_BR/normalizer.normalize.php";}s:25:"start_comments_line_index";i:48;s:26:"start_comments_token_index";i:407;s:23:"end_comments_line_index";i:49;s:24:"end_comments_token_index";i:407;s:22:"start_args_token_index";i:416;s:20:"end_args_token_index";i:418;s:9:"arguments";a:1:{s:2:"$s";N;}s:25:"start_brackets_line_index";i:49;s:26:"start_brackets_token_index";i:420;s:23:"end_brackets_line_index";i:116;s:24:"end_brackets_token_index";i:1322;s:14:"end_line_index";i:116;s:15:"end_token_index";i:1322;}s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";a:20:{s:4:"name";s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";s:16:"start_line_index";i:121;s:17:"start_token_index";i:1330;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:85:"//replace \n inside of double quotes variables, bc prettyPrint escapes the end lines.";i:1;s:54:"//Note that $text is a html code with php code inside.";i:2;s:173:"//This method should be used in the code generated by the PhpParser\PrettyPrinter\Standard->prettyPrint($stmts); See an example in CMSFileHandler::setMethodParamsFromContent";}s:25:"start_comments_line_index";i:118;s:26:"start_comments_token_index";i:1324;s:23:"end_comments_line_index";i:121;s:24:"end_comments_token_index";i:1328;s:22:"start_args_token_index";i:1337;s:20:"end_args_token_index";i:1339;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:121;s:26:"start_brackets_token_index";i:1341;s:23:"end_brackets_line_index";i:166;s:24:"end_brackets_token_index";i:1760;s:14:"end_line_index";i:166;s:15:"end_token_index";i:1760;}s:19:"replaceIfNotEscaped";a:21:{s:4:"name";s:19:"replaceIfNotEscaped";s:16:"start_line_index";i:172;s:17:"start_token_index";i:1766;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:154:"//Used in this class and in lib/org/phpframework/workflow/task/programming/createform/WorkFlowTaskImpl.php and lib/org/phpframework/.../CMSFileHandler.php";}s:12:"doc_comments";a:1:{i:0;s:224:"/**
	* replaceIfNotEscaped: replaces a string inside of another string if not escaped, this is, repace $to_replace by $to_replacement in $text if $to_replace not escaped. Return the new string with the values replaced.
	*/";}s:25:"start_comments_line_index";i:168;s:26:"start_comments_token_index";i:1762;s:23:"end_comments_line_index";i:172;s:24:"end_comments_token_index";i:1764;s:22:"start_args_token_index";i:1773;s:20:"end_args_token_index";i:1781;s:9:"arguments";a:3:{s:11:"$to_replace";N;s:12:"$replacement";N;s:5:"$text";N;}s:25:"start_brackets_line_index";i:172;s:26:"start_brackets_token_index";i:1783;s:23:"end_brackets_line_index";i:201;s:24:"end_brackets_token_index";i:2005;s:14:"end_line_index";i:201;s:15:"end_token_index";i:2005;}s:13:"stripCSlashes";a:21:{s:4:"name";s:13:"stripCSlashes";s:16:"start_line_index";i:238;s:17:"start_token_index";i:2013;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:726:"/*public static function replaceIfNotEscapedOld($to_replace, $replacement, $text) {
		if ($text) {
			$new_text = "";
			$pos = 0;
			
			do {
				$start_pos = mb_strpos($text, $to_replace, $pos);
				
				if ($start_pos !== false) {
					$escaped = self::isMBSubstrCharEscaped($text, $start_pos);
					$next_pos = $start_pos + strlen($to_replace);
					
					if (!$escaped)
						$new_text .= mb_substr($text, $pos, $start_pos - $pos) . $replacement;
					else
						$new_text .= mb_substr($text, $pos, $next_pos - $pos);
					
					$pos = $next_pos;
				}
				else
					$new_text .= mb_substr($text, $pos);
			}
			while($start_pos !== false);
			
			return $new_text;
		}
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:432:"/**
	* stripCSlashes: strip all slashes for all characters inside of $chars
	* Note that the stripcslashes and stripslashes have a diferent behaviour. The stripcslashes removes slashes for double quotes and the stripslashes remove slashes for a bunch of escaped chars. 
	* This method only removes the slashes for a specific chars and if the chars are escaped, this is, if there is "\\'", this method won't remove any slash.
	*/";}s:25:"start_comments_line_index";i:202;s:26:"start_comments_token_index";i:2007;s:23:"end_comments_line_index";i:237;s:24:"end_comments_token_index";i:2011;s:22:"start_args_token_index";i:2020;s:20:"end_args_token_index";i:2025;s:9:"arguments";a:2:{s:5:"$text";N;s:6:"$chars";N;}s:25:"start_brackets_line_index";i:238;s:26:"start_brackets_token_index";i:2027;s:23:"end_brackets_line_index";i:253;s:24:"end_brackets_token_index";i:2154;s:14:"end_line_index";i:253;s:15:"end_token_index";i:2154;}s:16:"stripCharSlashes";a:20:{s:4:"name";s:16:"stripCharSlashes";s:16:"start_line_index";i:258;s:17:"start_token_index";i:2158;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:73:"/**
	* stripCharSlashes: strip all slashes for a specific character
	*/";}s:25:"start_comments_line_index";i:255;s:26:"start_comments_token_index";i:2156;s:23:"end_comments_line_index";i:257;s:24:"end_comments_token_index";i:2156;s:22:"start_args_token_index";i:2165;s:20:"end_args_token_index";i:2170;s:9:"arguments";a:2:{s:5:"$text";N;s:5:"$char";N;}s:25:"start_brackets_line_index";i:258;s:26:"start_brackets_token_index";i:2172;s:23:"end_brackets_line_index";i:273;s:24:"end_brackets_token_index";i:2300;s:14:"end_line_index";i:273;s:15:"end_token_index";i:2300;}s:23:"addCSlashesExcludingPTL";a:21:{s:4:"name";s:23:"addCSlashesExcludingPTL";s:16:"start_line_index";i:303;s:17:"start_token_index";i:2308;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:440:"/*public static function stripCharSlashesOld($text, $char) {
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				$prev = mb_substr($text, $pos - 1, 1);
				
				if ($prev == "\\" && !self::isMBSubstrCharEscaped($text, $pos - 1))
					$text = mb_substr($text, 0, $pos - 1) . mb_substr($text, $pos);
				else
					$pos++;
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:440:"/**
	* addCSlashesExcludingPTL: add slashes to all characters inside of $chars but excluding the ptl instructions
	*	$text: is the html with ptl instructions
	* 	$chars are the chars to be escaped: like: '\\"'
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*
	* In the future change this method to use the mbStrSplit method instead of the mb_substr, bc the mb_substr method is too slow for long strings
	*/";}s:25:"start_comments_line_index";i:274;s:26:"start_comments_token_index";i:2302;s:23:"end_comments_line_index";i:302;s:24:"end_comments_token_index";i:2306;s:22:"start_args_token_index";i:2315;s:20:"end_args_token_index";i:2327;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:4:"true";}s:25:"start_brackets_line_index";i:303;s:26:"start_brackets_token_index";i:2329;s:23:"end_brackets_line_index";i:349;s:24:"end_brackets_token_index";i:2789;s:14:"end_line_index";i:349;s:15:"end_token_index";i:2789;}s:11:"addCSlashes";a:21:{s:4:"name";s:11:"addCSlashes";s:16:"start_line_index";i:412;s:17:"start_token_index";i:2797;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:1819:"/*public static function addCSlashesExcludingPTLOld($text, $chars, $php_vars_control = true) {
		$length = mb_strlen($text);
		$new_text = "";
		$start_pos = $end_pos = 0;
		
		do {
			$pos_1 = mb_strpos($text, "<ptl:", $start_pos);
			$pos_2 = mb_strpos($text, "<php:", $start_pos);
			$pos_3 = mb_strpos($text, "<?:", $start_pos);
			$pos_4 = mb_strpos($text, "<?php:", $start_pos);
			
			$end_pos = $pos_1;
			
			if (!$end_pos || ($pos_2 && $end_pos > $pos_2))
				$end_pos = $pos_2;
			
			if (!$end_pos || ($pos_3 && $end_pos > $pos_3))
				$end_pos = $pos_3;
			
			if (!$end_pos || ($pos_4 && $end_pos > $pos_4))
				$end_pos = $pos_4;
			
			if ($end_pos !== false) {
				$str = mb_substr($text, $start_pos, $end_pos - $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add previous code of ptl tag
				$start_pos = $length;
				
				//find start pos
				$double_quotes_open = $single_quotes_open = false;
				for ($i = $end_pos + 1; $i < $length; $i++) {
					$c = mb_substr($text, $i, 1);
					
					if ($c == '"' && !$single_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$double_quotes_open = !$double_quotes_open;
					else if ($c == "'" && !$double_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$single_quotes_open = !$single_quotes_open;
					else if ($c == ">" && !$double_quotes_open && !$single_quotes_open) {
						$start_pos = $i + 1;
						break;
					}
				}
				
				$new_text .= mb_substr($text, $end_pos, $start_pos - $end_pos); //add ptl tag
			}
			else {
				$str = mb_substr($text, $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add last code or all code if no tpl tags
			}
		}
		while($end_pos !== false);
		
		return $new_text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:676:"/**
	* addCSlashes: add slashes to all characters inside of $chars
	* Note that the addcslashes and addslashes have a diferent behaviour. The addcslashes adds slashes for all double quotes even if they are escaped and the addslashes remove slashes for a bunch of escaped chars. 
	* This method only adds slashes for a specific chars and if the chars are escaped, this is, if there is "\'", this method will add a slash to "\" and another to "'", converting the code to "\\\'". But if there a code like "\\'", this method will convert it to: "\\\'". This means that this code is intelligent.
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:350;s:26:"start_comments_token_index";i:2791;s:23:"end_comments_line_index";i:411;s:24:"end_comments_token_index";i:2795;s:22:"start_args_token_index";i:2804;s:20:"end_args_token_index";i:2816;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:412;s:26:"start_brackets_token_index";i:2818;s:23:"end_brackets_line_index";i:432;s:24:"end_brackets_token_index";i:2977;s:14:"end_line_index";i:432;s:15:"end_token_index";i:2977;}s:14:"addCharSlashes";a:20:{s:4:"name";s:14:"addCharSlashes";s:16:"start_line_index";i:443;s:17:"start_token_index";i:2981;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:388:"/**
	* addCharSlashes: add slashes for a specific character
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:434;s:26:"start_comments_token_index";i:2979;s:23:"end_comments_line_index";i:442;s:24:"end_comments_token_index";i:2979;s:22:"start_args_token_index";i:2988;s:20:"end_args_token_index";i:3007;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:443;s:26:"start_brackets_token_index";i:3009;s:23:"end_brackets_line_index";i:462;s:24:"end_brackets_token_index";i:3188;s:14:"end_line_index";i:462;s:15:"end_token_index";i:3188;}s:32:"addCharSlashesWithPHPVarsControl";a:21:{s:4:"name";s:32:"addCharSlashesWithPHPVarsControl";s:16:"start_line_index";i:506;s:17:"start_token_index";i:3196;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1005:"/*public static function addCharSlashesOld($text, $char, $add_slash_to_escaped_char = true, $php_vars_control = false) {
		if ($php_vars_control && (mb_strpos($text, '{$') !== false || mb_strpos($text, '${') !== false))
			return self::addCharSlashesWithPHPVarsControl($text, $char, $add_slash_to_escaped_char);
		
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $pos)) {
					$text = mb_substr($text, 0, $pos) . "\\\\" . mb_substr($text, $pos); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$pos += 3; //move $pos to the next position after $char
				}
				else {
					$text = mb_substr($text, 0, $pos) . "\\" . mb_substr($text, $pos); //only adds 1 slash to the $char
					$pos += 2; //move $pos to the next position after $char
				}
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:1115:"/**
	* addCharSlashesWithPHPVarsControl: add slashes for a specific character but only in the text outside of the php vars like ${...} or {$...}
	*
	* 	This is, checks if exists any '{$' or '${' and if yes, doesn't escapes anything inside of the brackets, bc it is a php var that should not be touched.
	* 		example: 
	*			'"' . self::addCharSlashes('this is a simple phrase with double quotes " and the var {$person["name"]}!', '"') . '"'
	*
	* 		When addCharSlashesWithPHPVarsControl is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person["name"]}!"'
	* 		When addCharSlashes is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person[\"name\"]}!"'
	*			...which will return a php error, bc what is inside of {$...} will be executed first in php!
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*/";}s:25:"start_comments_line_index";i:463;s:26:"start_comments_token_index";i:3190;s:23:"end_comments_line_index";i:505;s:24:"end_comments_token_index";i:3194;s:22:"start_args_token_index";i:3203;s:20:"end_args_token_index";i:3222;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:506;s:26:"start_brackets_token_index";i:3224;s:23:"end_brackets_line_index";i:526;s:24:"end_brackets_token_index";i:3454;s:14:"end_line_index";i:526;s:15:"end_token_index";i:3454;}s:10:"mbStrSplit";a:21:{s:4:"name";s:10:"mbStrSplit";s:16:"start_line_index";i:565;s:17:"start_token_index";i:3462;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1452:"/*public static function addCharSlashesWithPHPVarsControlOld($text, $char, $add_slash_to_escaped_char = true) {
		//error_log("addCharSlashesWithPHPVarsControl(\$text, $char, $add_slash_to_escaped_char\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		$l = mb_strlen($text);
		$is_var = 0;
		//error_log("length:$l|".strlen($text)."\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		for ($i = 0; $i < $l; $i++) {
			$c = mb_substr($text, $i, 1);
			
			if ($c == "$" && (mb_substr($text, $i - 1, 1) == "{" || mb_substr($text, $i + 1, 1) == "{") && !self::isMBSubstrCharEscaped($text, $i)) //{$...} or ${...}
				$is_var++;
			else if ($is_var && $c == "}")
				$is_var--;
			else if (!$is_var && $c == $char) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $i)) {
					$text = mb_substr($text, 0, $i) . "\\\\" . mb_substr($text, $i); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$i += 2; //move $pos to the new $char position
					$l += 2; //increase 2 char to length
				}
				else {
					$text = mb_substr($text, 0, $i) . "\\" . mb_substr($text, $i); //only adds 1 slash to the $char
					$i += 1; //move $pos to the new $char position
					$l += 1; //increase 1 char to length
				}
			}
		}
		//error_log("END\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:251:"/**
	* mbStrSplit: returns the multibyte character list of a string. 
	* This function splits a multibyte string into an array of characters. Comparable to str_split().
	* A (simpler) way to extract all characters from a UTF-8 string to array.
	*/";}s:25:"start_comments_line_index";i:527;s:26:"start_comments_token_index";i:3456;s:23:"end_comments_line_index";i:564;s:24:"end_comments_token_index";i:3460;s:22:"start_args_token_index";i:3469;s:20:"end_args_token_index";i:3471;s:9:"arguments";a:1:{s:4:"$str";N;}s:25:"start_brackets_line_index";i:565;s:26:"start_brackets_token_index";i:3473;s:23:"end_brackets_line_index";i:569;s:24:"end_brackets_token_index";i:3510;s:14:"end_line_index";i:569;s:15:"end_token_index";i:3510;}s:13:"isCharEscaped";a:20:{s:4:"name";s:13:"isCharEscaped";s:16:"start_line_index";i:574;s:17:"start_token_index";i:3514;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:571;s:26:"start_comments_token_index";i:3512;s:23:"end_comments_line_index";i:573;s:24:"end_comments_token_index";i:3512;s:22:"start_args_token_index";i:3521;s:20:"end_args_token_index";i:3526;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:574;s:26:"start_brackets_token_index";i:3528;s:23:"end_brackets_line_index";i:585;s:24:"end_brackets_token_index";i:3597;s:14:"end_line_index";i:585;s:15:"end_token_index";i:3597;}s:15:"isMBCharEscaped";a:20:{s:4:"name";s:15:"isMBCharEscaped";s:16:"start_line_index";i:590;s:17:"start_token_index";i:3601;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:587;s:26:"start_comments_token_index";i:3599;s:23:"end_comments_line_index";i:589;s:24:"end_comments_token_index";i:3599;s:22:"start_args_token_index";i:3608;s:20:"end_args_token_index";i:3620;s:9:"arguments";a:3:{s:4:"$str";N;s:6:"$index";N;s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:590;s:26:"start_brackets_token_index";i:3622;s:23:"end_brackets_line_index";i:602;s:24:"end_brackets_token_index";i:3711;s:14:"end_line_index";i:602;s:15:"end_token_index";i:3711;}s:21:"isMBSubstrCharEscaped";a:20:{s:4:"name";s:21:"isMBSubstrCharEscaped";s:16:"start_line_index";i:607;s:17:"start_token_index";i:3715;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:118:"/**
	* isMBSubstrCharEscaped: checks if a char is escaped given its position based in the mb_substr php function
	*/";}s:25:"start_comments_line_index";i:604;s:26:"start_comments_token_index";i:3713;s:23:"end_comments_line_index";i:606;s:24:"end_comments_token_index";i:3713;s:22:"start_args_token_index";i:3722;s:20:"end_args_token_index";i:3727;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:607;s:26:"start_brackets_token_index";i:3729;s:23:"end_brackets_line_index";i:618;s:24:"end_brackets_token_index";i:3804;s:14:"end_line_index";i:618;s:15:"end_token_index";i:3804;}s:9:"isBadWord";a:20:{s:4:"name";s:9:"isBadWord";s:16:"start_line_index";i:623;s:17:"start_token_index";i:3808;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:59:"/**
	* isBadWord: verifies if a string is a bad word.
	*/";}s:25:"start_comments_line_index";i:620;s:26:"start_comments_token_index";i:3806;s:23:"end_comments_line_index";i:622;s:24:"end_comments_token_index";i:3806;s:22:"start_args_token_index";i:3815;s:20:"end_args_token_index";i:3817;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:623;s:26:"start_brackets_token_index";i:3819;s:23:"end_brackets_line_index";i:631;s:24:"end_brackets_token_index";i:3866;s:14:"end_line_index";i:631;s:15:"end_token_index";i:3866;}s:15:"replaceBadWords";a:20:{s:4:"name";s:15:"replaceBadWords";s:16:"start_line_index";i:636;s:17:"start_token_index";i:3870;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:64:"/**
	* replaceBadWords: replaces bad words with nicer ones
	*/";}s:25:"start_comments_line_index";i:633;s:26:"start_comments_token_index";i:3868;s:23:"end_comments_line_index";i:635;s:24:"end_comments_token_index";i:3868;s:22:"start_args_token_index";i:3877;s:20:"end_args_token_index";i:3879;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:636;s:26:"start_brackets_token_index";i:3881;s:23:"end_brackets_line_index";i:643;s:24:"end_brackets_token_index";i:3928;s:14:"end_line_index";i:643;s:15:"end_token_index";i:3928;}s:15:"replaceWebLinks";a:20:{s:4:"name";s:15:"replaceWebLinks";s:16:"start_line_index";i:648;s:17:"start_token_index";i:3932;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:48:"/**
	* replaceWebLinks: replaces web links
	*/";}s:25:"start_comments_line_index";i:645;s:26:"start_comments_token_index";i:3930;s:23:"end_comments_line_index";i:647;s:24:"end_comments_token_index";i:3930;s:22:"start_args_token_index";i:3939;s:20:"end_args_token_index";i:3948;s:9:"arguments";a:2:{s:7:"$string";N;s:12:"$replacement";s:2:"""";}s:25:"start_brackets_line_index";i:648;s:26:"start_brackets_token_index";i:3950;s:23:"end_brackets_line_index";i:681;s:24:"end_brackets_token_index";i:4186;s:14:"end_line_index";i:681;s:15:"end_token_index";i:4186;}s:14:"breakLongWords";a:20:{s:4:"name";s:14:"breakLongWords";s:16:"start_line_index";i:686;s:17:"start_token_index";i:4190;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:46:"/**
	* breakLongWords: breaks long words
	*/";}s:25:"start_comments_line_index";i:683;s:26:"start_comments_token_index";i:4188;s:23:"end_comments_line_index";i:685;s:24:"end_comments_token_index";i:4188;s:22:"start_args_token_index";i:4197;s:20:"end_args_token_index";i:4213;s:9:"arguments";a:3:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:686;s:26:"start_brackets_token_index";i:4215;s:23:"end_brackets_line_index";i:690;s:24:"end_brackets_token_index";i:4263;s:14:"end_line_index";i:690;s:15:"end_token_index";i:4263;}s:18:"breakLongTextWords";a:20:{s:4:"name";s:18:"breakLongTextWords";s:16:"start_line_index";i:695;s:17:"start_token_index";i:4267;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongTextWords: breaks long text words
	*/";}s:25:"start_comments_line_index";i:692;s:26:"start_comments_token_index";i:4265;s:23:"end_comments_line_index";i:694;s:24:"end_comments_token_index";i:4265;s:22:"start_args_token_index";i:4274;s:20:"end_args_token_index";i:4283;s:9:"arguments";a:2:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";}s:25:"start_brackets_line_index";i:695;s:26:"start_brackets_token_index";i:4285;s:23:"end_brackets_line_index";i:713;s:24:"end_brackets_token_index";i:4429;s:14:"end_line_index";i:713;s:15:"end_token_index";i:4429;}s:18:"breakLongHtmlWords";a:20:{s:4:"name";s:18:"breakLongHtmlWords";s:16:"start_line_index";i:718;s:17:"start_token_index";i:4433;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongHtmlWords: breaks long html words
	*/";}s:25:"start_comments_line_index";i:715;s:26:"start_comments_token_index";i:4431;s:23:"end_comments_line_index";i:717;s:24:"end_comments_token_index";i:4431;s:22:"start_args_token_index";i:4440;s:20:"end_args_token_index";i:4456;s:9:"arguments";a:3:{s:4:"$str";N;s:10:"$maxLength";s:2:"20";s:5:"$char";s:3:"" "";}s:25:"start_brackets_line_index";i:718;s:26:"start_brackets_token_index";i:4457;s:23:"end_brackets_line_index";i:751;s:24:"end_brackets_token_index";i:4681;s:14:"end_line_index";i:751;s:15:"end_token_index";i:4681;}s:14:"sanitizeString";a:20:{s:4:"name";s:14:"sanitizeString";s:16:"start_line_index";i:756;s:17:"start_token_index";i:4685;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:29:"/**
	* sanitizeString: 
	*/";}s:25:"start_comments_line_index";i:753;s:26:"start_comments_token_index";i:4683;s:23:"end_comments_line_index";i:755;s:24:"end_comments_token_index";i:4683;s:22:"start_args_token_index";i:4692;s:20:"end_args_token_index";i:4701;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:756;s:26:"start_brackets_token_index";i:4703;s:23:"end_brackets_line_index";i:764;s:24:"end_brackets_token_index";i:4758;s:14:"end_line_index";i:764;s:15:"end_token_index";i:4758;}s:12:"sanitizeText";a:20:{s:4:"name";s:12:"sanitizeText";s:16:"start_line_index";i:769;s:17:"start_token_index";i:4762;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:27:"/**
	* sanitizeText: 
	*/";}s:25:"start_comments_line_index";i:766;s:26:"start_comments_token_index";i:4760;s:23:"end_comments_line_index";i:768;s:24:"end_comments_token_index";i:4760;s:22:"start_args_token_index";i:4769;s:20:"end_args_token_index";i:4778;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:769;s:26:"start_brackets_token_index";i:4780;s:23:"end_brackets_line_index";i:788;s:24:"end_brackets_token_index";i:4949;s:14:"end_line_index";i:788;s:15:"end_token_index";i:4949;}}}}
a:1:{s:42:"MemcacheServiceCacheRelatedServicesHandler";a:2:{s:7:"methods";a:7:{s:31:"addServiceToRelatedKeysToDelete";a:20:{s:4:"name";s:31:"addServiceToRelatedKeysToDelete";s:16:"start_line_index";i:16;s:17:"start_token_index";i:62;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:156:"/*
		1. Based in the $service_related_keys_to_delete, loop them and for each
		2. add the new service $key to each $service_related_keys_to_delete item.
	*/";}s:25:"start_comments_line_index";i:12;s:26:"start_comments_token_index";i:60;s:23:"end_comments_line_index";i:15;s:24:"end_comments_token_index";i:60;s:22:"start_args_token_index";i:67;s:20:"end_args_token_index";i:82;s:9:"arguments";a:4:{s:7:"$prefix";N;s:4:"$key";N;s:31:"$service_related_keys_to_delete";N;s:5:"$type";s:5:"false";}s:25:"start_brackets_line_index";i:16;s:26:"start_brackets_token_index";i:84;s:23:"end_brackets_line_index";i:43;s:24:"end_brackets_token_index";i:350;s:14:"end_line_index";i:43;s:15:"end_token_index";i:350;}s:21:"addServiceKeyToDelete";a:20:{s:4:"name";s:21:"addServiceKeyToDelete";s:16:"start_line_index";i:48;s:17:"start_token_index";i:354;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:121:"/*
		1. ADD $key TO A GENERIC "TABLE". ALL KEYS WILL BE IN THIS GENERIC "TABLE", SO WE CAN EXECUTE THE delete_mode==2
	*/";}s:25:"start_comments_line_index";i:45;s:26:"start_comments_token_index";i:352;s:23:"end_comments_line_index";i:47;s:24:"end_comments_token_index";i:352;s:22:"start_args_token_index";i:359;s:20:"end_args_token_index";i:371;s:9:"arguments";a:3:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";s:5:"false";}s:25:"start_brackets_line_index";i:48;s:26:"start_brackets_token_index";i:373;s:23:"end_brackets_line_index";i:64;s:24:"end_brackets_token_index";i:470;s:14:"end_line_index";i:64;s:15:"end_token_index";i:470;}s:6:"delete";a:15:{s:4:"name";s:6:"delete";s:16:"start_line_index";i:66;s:17:"start_token_index";i:472;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:477;s:20:"end_args_token_index";i:491;s:9:"arguments";a:5:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:9:"$key_type";N;s:13:"$original_key";N;}s:25:"start_brackets_line_index";i:66;s:26:"start_brackets_token_index";i:493;s:23:"end_brackets_line_index";i:70;s:24:"end_brackets_token_index";i:538;s:14:"end_line_index";i:70;s:15:"end_token_index";i:538;}s:43:"deleteBySearchingInAllTheCreatedCachedItems";a:15:{s:4:"name";s:43:"deleteBySearchingInAllTheCreatedCachedItems";s:16:"start_line_index";i:72;s:17:"start_token_index";i:540;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:22:"start_args_token_index";i:545;s:20:"end_args_token_index";i:556;s:9:"arguments";a:4:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:9:"$key_type";N;}s:25:"start_brackets_line_index";i:72;s:26:"start_brackets_token_index";i:558;s:23:"end_brackets_line_index";i:77;s:24:"end_brackets_token_index";i:599;s:14:"end_line_index";i:77;s:15:"end_token_index";i:599;}s:25:"deleteRelatedServicesKeys";a:20:{s:4:"name";s:25:"deleteRelatedServicesKeys";s:16:"start_line_index";i:89;s:17:"start_token_index";i:605;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:2:{i:0;s:601:"/*
		1. Based in the "dir_path" memcache key, get the memcache value. This value will be an array with all the correspondent memcache keys which contain the array of items.
		2. loop the value/array and for each item (new memcache key), gets the correspondent memcache value, which will be an array with service items keys.
		3. checks if the value is an array and if it is, loop it
		4. for each element, cheks if checkIfKeyTypeMatchValue, this is, checks if the TYPE (prefix, suffix, regex...) of the $key is in the $arr_key.
		5. If it is, remove the correspondent $arr_key service cached data.
	*/";i:1;s:138:"/*
	 * TODO: create threads support. This means for each group of 5 files, launch a new thread and delete the correspondent services.
	 */";}s:25:"start_comments_line_index";i:79;s:26:"start_comments_token_index";i:601;s:23:"end_comments_line_index";i:88;s:24:"end_comments_token_index";i:603;s:22:"start_args_token_index";i:610;s:20:"end_args_token_index";i:624;s:9:"arguments";a:5:{s:7:"$prefix";N;s:4:"$key";N;s:5:"$type";N;s:9:"$key_type";N;s:9:"$dir_path";N;}s:25:"start_brackets_line_index";i:89;s:26:"start_brackets_token_index";i:626;s:23:"end_brackets_line_index";i:123;s:24:"end_brackets_token_index";i:923;s:14:"end_line_index";i:123;s:15:"end_token_index";i:923;}s:14:"getFilePathKey";a:20:{s:4:"name";s:14:"getFilePathKey";s:16:"start_line_index";i:135;s:17:"start_token_index";i:927;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:667:"/*
		1. Based in the "dir_path" memcache key, get the memcache value. This value will be an array with all the correspondent memcache keys which contain the array of items.
		2. loop the value/array and for each item (new memcache key), gets the correspondent memcache value, which will be an array with service items keys.
		3. checks if the value is an array and if it is, loop it
		4. for each element, cheks if key exists and if it does:
			$key_file_path = $file_path;
		5. otherwise for each element checks if count($arr) < self::MAXIMUM_ITEMS_PER_FILE, and if it does:
			$free_file_paths[] = $file_path;
		6. if $key_file_path is set and exists, do break;
	*/";}s:25:"start_comments_line_index";i:125;s:26:"start_comments_token_index";i:925;s:23:"end_comments_line_index";i:134;s:24:"end_comments_token_index";i:925;s:22:"start_args_token_index";i:932;s:20:"end_args_token_index";i:937;s:9:"arguments";a:2:{s:9:"$dir_path";N;s:4:"$key";N;}s:25:"start_brackets_line_index";i:135;s:26:"start_brackets_token_index";i:939;s:23:"end_brackets_line_index";i:159;s:24:"end_brackets_token_index";i:1162;s:14:"end_line_index";i:159;s:15:"end_token_index";i:1162;}s:11:"registerKey";a:20:{s:4:"name";s:11:"registerKey";s:16:"start_line_index";i:165;s:17:"start_token_index";i:1166;s:4:"type";s:9:"protected";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:195:"/*
		1. Checks if exists any file in the $free_file_paths which contains less than MAXIMUM_ITEMS_PER_FILE and if yes, add the $key item.
		2. Otherwise create new file inside of the $dir_path
	*/";}s:25:"start_comments_line_index";i:161;s:26:"start_comments_token_index";i:1164;s:23:"end_comments_line_index";i:164;s:24:"end_comments_token_index";i:1164;s:22:"start_args_token_index";i:1171;s:20:"end_args_token_index";i:1179;s:9:"arguments";a:3:{s:9:"$dir_path";N;s:4:"$key";N;s:16:"$free_file_paths";N;}s:25:"start_brackets_line_index";i:165;s:26:"start_brackets_token_index";i:1181;s:23:"end_brackets_line_index";i:220;s:24:"end_brackets_token_index";i:1591;s:14:"end_line_index";i:220;s:15:"end_token_index";i:1591;}}s:5:"props";a:1:{s:57:"MEMCACHE_KEY_NAMES_WITH_THE_OTHER_MEMCACHE_KEYS_FILE_NAME";a:16:{s:4:"name";s:57:"MEMCACHE_KEY_NAMES_WITH_THE_OTHER_MEMCACHE_KEYS_FILE_NAME";s:4:"type";s:6:"public";s:5:"value";s:21:""asdakl3kl24234jk23l"";s:8:"var_type";s:6:"string";s:6:"static";b:0;s:8:"abstract";b:0;s:5:"const";b:1;s:16:"start_line_index";i:6;s:17:"start_token_index";i:29;s:14:"end_line_index";i:6;s:15:"end_token_index";i:36;s:8:"comments";a:1:{i:0;s:13:"/*protected*/";}s:25:"start_comments_line_index";i:6;s:26:"start_comments_token_index";i:27;s:23:"end_comments_line_index";i:6;s:24:"end_comments_token_index";i:27;}}}}
a:1:{s:13:"TextSanitizer";a:1:{s:7:"methods";a:21:{s:16:"normalizeAccents";a:20:{s:4:"name";s:16:"normalizeAccents";s:16:"start_line_index";i:5;s:17:"start_token_index";i:9;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:71:"//copied from https://www.php.net/manual/pt_BR/normalizer.normalize.php";}s:25:"start_comments_line_index";i:4;s:26:"start_comments_token_index";i:7;s:23:"end_comments_line_index";i:5;s:24:"end_comments_token_index";i:7;s:22:"start_args_token_index";i:16;s:20:"end_args_token_index";i:18;s:9:"arguments";a:1:{s:2:"$s";N;}s:25:"start_brackets_line_index";i:5;s:26:"start_brackets_token_index";i:20;s:23:"end_brackets_line_index";i:72;s:24:"end_brackets_token_index";i:922;s:14:"end_line_index";i:72;s:15:"end_token_index";i:922;}s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";a:20:{s:4:"name";s:55:"replaceEscapedEndLinesInsideOfPHPDoubleQuotesInHtmlCode";s:16:"start_line_index";i:77;s:17:"start_token_index";i:930;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:3:{i:0;s:85:"//replace \n inside of double quotes variables, bc prettyPrint escapes the end lines.";i:1;s:54:"//Note that $text is a html code with php code inside.";i:2;s:173:"//This method should be used in the code generated by the PhpParser\PrettyPrinter\Standard->prettyPrint($stmts); See an example in CMSFileHandler::setMethodParamsFromContent";}s:25:"start_comments_line_index";i:74;s:26:"start_comments_token_index";i:924;s:23:"end_comments_line_index";i:77;s:24:"end_comments_token_index";i:928;s:22:"start_args_token_index";i:937;s:20:"end_args_token_index";i:939;s:9:"arguments";a:1:{s:5:"$text";N;}s:25:"start_brackets_line_index";i:77;s:26:"start_brackets_token_index";i:941;s:23:"end_brackets_line_index";i:122;s:24:"end_brackets_token_index";i:1360;s:14:"end_line_index";i:122;s:15:"end_token_index";i:1360;}s:19:"replaceIfNotEscaped";a:21:{s:4:"name";s:19:"replaceIfNotEscaped";s:16:"start_line_index";i:128;s:17:"start_token_index";i:1366;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:154:"//Used in this class and in lib/org/phpframework/workflow/task/programming/createform/WorkFlowTaskImpl.php and lib/org/phpframework/.../CMSFileHandler.php";}s:12:"doc_comments";a:1:{i:0;s:224:"/**
	* replaceIfNotEscaped: replaces a string inside of another string if not escaped, this is, repace $to_replace by $to_replacement in $text if $to_replace not escaped. Return the new string with the values replaced.
	*/";}s:25:"start_comments_line_index";i:124;s:26:"start_comments_token_index";i:1362;s:23:"end_comments_line_index";i:128;s:24:"end_comments_token_index";i:1364;s:22:"start_args_token_index";i:1373;s:20:"end_args_token_index";i:1381;s:9:"arguments";a:3:{s:11:"$to_replace";N;s:12:"$replacement";N;s:5:"$text";N;}s:25:"start_brackets_line_index";i:128;s:26:"start_brackets_token_index";i:1383;s:23:"end_brackets_line_index";i:157;s:24:"end_brackets_token_index";i:1605;s:14:"end_line_index";i:157;s:15:"end_token_index";i:1605;}s:13:"stripCSlashes";a:21:{s:4:"name";s:13:"stripCSlashes";s:16:"start_line_index";i:194;s:17:"start_token_index";i:1613;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:726:"/*public static function replaceIfNotEscapedOld($to_replace, $replacement, $text) {
		if ($text) {
			$new_text = "";
			$pos = 0;
			
			do {
				$start_pos = mb_strpos($text, $to_replace, $pos);
				
				if ($start_pos !== false) {
					$escaped = self::isMBSubstrCharEscaped($text, $start_pos);
					$next_pos = $start_pos + strlen($to_replace);
					
					if (!$escaped)
						$new_text .= mb_substr($text, $pos, $start_pos - $pos) . $replacement;
					else
						$new_text .= mb_substr($text, $pos, $next_pos - $pos);
					
					$pos = $next_pos;
				}
				else
					$new_text .= mb_substr($text, $pos);
			}
			while($start_pos !== false);
			
			return $new_text;
		}
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:432:"/**
	* stripCSlashes: strip all slashes for all characters inside of $chars
	* Note that the stripcslashes and stripslashes have a diferent behaviour. The stripcslashes removes slashes for double quotes and the stripslashes remove slashes for a bunch of escaped chars. 
	* This method only removes the slashes for a specific chars and if the chars are escaped, this is, if there is "\\'", this method won't remove any slash.
	*/";}s:25:"start_comments_line_index";i:158;s:26:"start_comments_token_index";i:1607;s:23:"end_comments_line_index";i:193;s:24:"end_comments_token_index";i:1611;s:22:"start_args_token_index";i:1620;s:20:"end_args_token_index";i:1625;s:9:"arguments";a:2:{s:5:"$text";N;s:6:"$chars";N;}s:25:"start_brackets_line_index";i:194;s:26:"start_brackets_token_index";i:1627;s:23:"end_brackets_line_index";i:209;s:24:"end_brackets_token_index";i:1754;s:14:"end_line_index";i:209;s:15:"end_token_index";i:1754;}s:16:"stripCharSlashes";a:20:{s:4:"name";s:16:"stripCharSlashes";s:16:"start_line_index";i:214;s:17:"start_token_index";i:1758;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:73:"/**
	* stripCharSlashes: strip all slashes for a specific character
	*/";}s:25:"start_comments_line_index";i:211;s:26:"start_comments_token_index";i:1756;s:23:"end_comments_line_index";i:213;s:24:"end_comments_token_index";i:1756;s:22:"start_args_token_index";i:1765;s:20:"end_args_token_index";i:1770;s:9:"arguments";a:2:{s:5:"$text";N;s:5:"$char";N;}s:25:"start_brackets_line_index";i:214;s:26:"start_brackets_token_index";i:1772;s:23:"end_brackets_line_index";i:229;s:24:"end_brackets_token_index";i:1900;s:14:"end_line_index";i:229;s:15:"end_token_index";i:1900;}s:23:"addCSlashesExcludingPTL";a:21:{s:4:"name";s:23:"addCSlashesExcludingPTL";s:16:"start_line_index";i:259;s:17:"start_token_index";i:1908;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:440:"/*public static function stripCharSlashesOld($text, $char) {
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				$prev = mb_substr($text, $pos - 1, 1);
				
				if ($prev == "\\" && !self::isMBSubstrCharEscaped($text, $pos - 1))
					$text = mb_substr($text, 0, $pos - 1) . mb_substr($text, $pos);
				else
					$pos++;
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:440:"/**
	* addCSlashesExcludingPTL: add slashes to all characters inside of $chars but excluding the ptl instructions
	*	$text: is the html with ptl instructions
	* 	$chars are the chars to be escaped: like: '\\"'
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*
	* In the future change this method to use the mbStrSplit method instead of the mb_substr, bc the mb_substr method is too slow for long strings
	*/";}s:25:"start_comments_line_index";i:230;s:26:"start_comments_token_index";i:1902;s:23:"end_comments_line_index";i:258;s:24:"end_comments_token_index";i:1906;s:22:"start_args_token_index";i:1915;s:20:"end_args_token_index";i:1927;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:4:"true";}s:25:"start_brackets_line_index";i:259;s:26:"start_brackets_token_index";i:1929;s:23:"end_brackets_line_index";i:305;s:24:"end_brackets_token_index";i:2389;s:14:"end_line_index";i:305;s:15:"end_token_index";i:2389;}s:11:"addCSlashes";a:21:{s:4:"name";s:11:"addCSlashes";s:16:"start_line_index";i:368;s:17:"start_token_index";i:2397;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//This method is deprecated bc is a little bit more slow";i:1;s:1819:"/*public static function addCSlashesExcludingPTLOld($text, $chars, $php_vars_control = true) {
		$length = mb_strlen($text);
		$new_text = "";
		$start_pos = $end_pos = 0;
		
		do {
			$pos_1 = mb_strpos($text, "<ptl:", $start_pos);
			$pos_2 = mb_strpos($text, "<php:", $start_pos);
			$pos_3 = mb_strpos($text, "<?:", $start_pos);
			$pos_4 = mb_strpos($text, "<?php:", $start_pos);
			
			$end_pos = $pos_1;
			
			if (!$end_pos || ($pos_2 && $end_pos > $pos_2))
				$end_pos = $pos_2;
			
			if (!$end_pos || ($pos_3 && $end_pos > $pos_3))
				$end_pos = $pos_3;
			
			if (!$end_pos || ($pos_4 && $end_pos > $pos_4))
				$end_pos = $pos_4;
			
			if ($end_pos !== false) {
				$str = mb_substr($text, $start_pos, $end_pos - $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add previous code of ptl tag
				$start_pos = $length;
				
				//find start pos
				$double_quotes_open = $single_quotes_open = false;
				for ($i = $end_pos + 1; $i < $length; $i++) {
					$c = mb_substr($text, $i, 1);
					
					if ($c == '"' && !$single_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$double_quotes_open = !$double_quotes_open;
					else if ($c == "'" && !$double_quotes_open && !self::isMBSubstrCharEscaped($text, $i))
						$single_quotes_open = !$single_quotes_open;
					else if ($c == ">" && !$double_quotes_open && !$single_quotes_open) {
						$start_pos = $i + 1;
						break;
					}
				}
				
				$new_text .= mb_substr($text, $end_pos, $start_pos - $end_pos); //add ptl tag
			}
			else {
				$str = mb_substr($text, $start_pos);
				$new_text .= self::addCSlashes($str, $chars, $php_vars_control); //add last code or all code if no tpl tags
			}
		}
		while($end_pos !== false);
		
		return $new_text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:676:"/**
	* addCSlashes: add slashes to all characters inside of $chars
	* Note that the addcslashes and addslashes have a diferent behaviour. The addcslashes adds slashes for all double quotes even if they are escaped and the addslashes remove slashes for a bunch of escaped chars. 
	* This method only adds slashes for a specific chars and if the chars are escaped, this is, if there is "\'", this method will add a slash to "\" and another to "'", converting the code to "\\\'". But if there a code like "\\'", this method will convert it to: "\\\'". This means that this code is intelligent.
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:306;s:26:"start_comments_token_index";i:2391;s:23:"end_comments_line_index";i:367;s:24:"end_comments_token_index";i:2395;s:22:"start_args_token_index";i:2404;s:20:"end_args_token_index";i:2416;s:9:"arguments";a:3:{s:5:"$text";N;s:6:"$chars";N;s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:368;s:26:"start_brackets_token_index";i:2418;s:23:"end_brackets_line_index";i:388;s:24:"end_brackets_token_index";i:2577;s:14:"end_line_index";i:388;s:15:"end_token_index";i:2577;}s:14:"addCharSlashes";a:20:{s:4:"name";s:14:"addCharSlashes";s:16:"start_line_index";i:399;s:17:"start_token_index";i:2581;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:388:"/**
	* addCharSlashes: add slashes for a specific character
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*
	* 	$php_vars_control: check the addCharSlashesWithPHPVarsControl method
	*/";}s:25:"start_comments_line_index";i:390;s:26:"start_comments_token_index";i:2579;s:23:"end_comments_line_index";i:398;s:24:"end_comments_token_index";i:2579;s:22:"start_args_token_index";i:2588;s:20:"end_args_token_index";i:2607;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:17:"$php_vars_control";s:5:"false";}s:25:"start_brackets_line_index";i:399;s:26:"start_brackets_token_index";i:2609;s:23:"end_brackets_line_index";i:418;s:24:"end_brackets_token_index";i:2788;s:14:"end_line_index";i:418;s:15:"end_token_index";i:2788;}s:32:"addCharSlashesWithPHPVarsControl";a:21:{s:4:"name";s:32:"addCharSlashesWithPHPVarsControl";s:16:"start_line_index";i:462;s:17:"start_token_index";i:2796;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1005:"/*public static function addCharSlashesOld($text, $char, $add_slash_to_escaped_char = true, $php_vars_control = false) {
		if ($php_vars_control && (mb_strpos($text, '{$') !== false || mb_strpos($text, '${') !== false))
			return self::addCharSlashesWithPHPVarsControl($text, $char, $add_slash_to_escaped_char);
		
		$pos = 0;
		
		do {
			$pos = mb_strpos($text, $char, $pos);
			
			if ($pos !== false) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $pos)) {
					$text = mb_substr($text, 0, $pos) . "\\\\" . mb_substr($text, $pos); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$pos += 3; //move $pos to the next position after $char
				}
				else {
					$text = mb_substr($text, 0, $pos) . "\\" . mb_substr($text, $pos); //only adds 1 slash to the $char
					$pos += 2; //move $pos to the next position after $char
				}
			}
		}
		while ($pos !== false);
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:1115:"/**
	* addCharSlashesWithPHPVarsControl: add slashes for a specific character but only in the text outside of the php vars like ${...} or {$...}
	*
	* 	This is, checks if exists any '{$' or '${' and if yes, doesn't escapes anything inside of the brackets, bc it is a php var that should not be touched.
	* 		example: 
	*			'"' . self::addCharSlashes('this is a simple phrase with double quotes " and the var {$person["name"]}!', '"') . '"'
	*
	* 		When addCharSlashesWithPHPVarsControl is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person["name"]}!"'
	* 		When addCharSlashes is called, then the it will return:
	*			'"this is a simple phrase with double quotes \" and the var {$person[\"name\"]}!"'
	*			...which will return a php error, bc what is inside of {$...} will be executed first in php!
	*
	* 	$add_slash_to_escaped_char: 
	* 		if true, detects if the $char is escaped (this is if there is a slash before) and if it is, escapes the char and the previous slash that was escaping the $char
	* 		if false, simply escapes the $char
	*/";}s:25:"start_comments_line_index";i:419;s:26:"start_comments_token_index";i:2790;s:23:"end_comments_line_index";i:461;s:24:"end_comments_token_index";i:2794;s:22:"start_args_token_index";i:2803;s:20:"end_args_token_index";i:2822;s:9:"arguments";a:4:{s:5:"$text";N;s:5:"$char";N;s:26:"$add_slash_to_escaped_char";s:4:"true";s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:462;s:26:"start_brackets_token_index";i:2824;s:23:"end_brackets_line_index";i:482;s:24:"end_brackets_token_index";i:3054;s:14:"end_line_index";i:482;s:15:"end_token_index";i:3054;}s:10:"mbStrSplit";a:21:{s:4:"name";s:10:"mbStrSplit";s:16:"start_line_index";i:521;s:17:"start_token_index";i:3062;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:121:"//This method is deprecated bc mb_substr is too slow. mb_substr should only be used if we don't change the $text it-self.";i:1;s:1452:"/*public static function addCharSlashesWithPHPVarsControlOld($text, $char, $add_slash_to_escaped_char = true) {
		//error_log("addCharSlashesWithPHPVarsControl(\$text, $char, $add_slash_to_escaped_char\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		$l = mb_strlen($text);
		$is_var = 0;
		//error_log("length:$l|".strlen($text)."\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		for ($i = 0; $i < $l; $i++) {
			$c = mb_substr($text, $i, 1);
			
			if ($c == "$" && (mb_substr($text, $i - 1, 1) == "{" || mb_substr($text, $i + 1, 1) == "{") && !self::isMBSubstrCharEscaped($text, $i)) //{$...} or ${...}
				$is_var++;
			else if ($is_var && $c == "}")
				$is_var--;
			else if (!$is_var && $c == $char) {
				if ($add_slash_to_escaped_char && self::isMBSubstrCharEscaped($text, $i)) {
					$text = mb_substr($text, 0, $i) . "\\\\" . mb_substr($text, $i); //adds 2 slashes: one for the existent slash that escapes the $char, and another adds a 2nd slash to the $char
					$i += 2; //move $pos to the new $char position
					$l += 2; //increase 2 char to length
				}
				else {
					$text = mb_substr($text, 0, $i) . "\\" . mb_substr($text, $i); //only adds 1 slash to the $char
					$i += 1; //move $pos to the new $char position
					$l += 1; //increase 1 char to length
				}
			}
		}
		//error_log("END\n\n", 3, "/var/www/html/livingroop/default/tmp/test.log");
		
		return $text;
	}*/";}s:12:"doc_comments";a:1:{i:0;s:251:"/**
	* mbStrSplit: returns the multibyte character list of a string. 
	* This function splits a multibyte string into an array of characters. Comparable to str_split().
	* A (simpler) way to extract all characters from a UTF-8 string to array.
	*/";}s:25:"start_comments_line_index";i:483;s:26:"start_comments_token_index";i:3056;s:23:"end_comments_line_index";i:520;s:24:"end_comments_token_index";i:3060;s:22:"start_args_token_index";i:3069;s:20:"end_args_token_index";i:3071;s:9:"arguments";a:1:{s:4:"$str";N;}s:25:"start_brackets_line_index";i:521;s:26:"start_brackets_token_index";i:3073;s:23:"end_brackets_line_index";i:525;s:24:"end_brackets_token_index";i:3110;s:14:"end_line_index";i:525;s:15:"end_token_index";i:3110;}s:13:"isCharEscaped";a:20:{s:4:"name";s:13:"isCharEscaped";s:16:"start_line_index";i:530;s:17:"start_token_index";i:3114;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:527;s:26:"start_comments_token_index";i:3112;s:23:"end_comments_line_index";i:529;s:24:"end_comments_token_index";i:3112;s:22:"start_args_token_index";i:3121;s:20:"end_args_token_index";i:3126;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:530;s:26:"start_brackets_token_index";i:3128;s:23:"end_brackets_line_index";i:541;s:24:"end_brackets_token_index";i:3197;s:14:"end_line_index";i:541;s:15:"end_token_index";i:3197;}s:15:"isMBCharEscaped";a:20:{s:4:"name";s:15:"isMBCharEscaped";s:16:"start_line_index";i:546;s:17:"start_token_index";i:3201;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:75:"/**
	* isCharEscaped: checks if a char is escaped given its position 
	*/";}s:25:"start_comments_line_index";i:543;s:26:"start_comments_token_index";i:3199;s:23:"end_comments_line_index";i:545;s:24:"end_comments_token_index";i:3199;s:22:"start_args_token_index";i:3208;s:20:"end_args_token_index";i:3220;s:9:"arguments";a:3:{s:4:"$str";N;s:6:"$index";N;s:11:"$text_chars";s:4:"null";}s:25:"start_brackets_line_index";i:546;s:26:"start_brackets_token_index";i:3222;s:23:"end_brackets_line_index";i:558;s:24:"end_brackets_token_index";i:3311;s:14:"end_line_index";i:558;s:15:"end_token_index";i:3311;}s:21:"isMBSubstrCharEscaped";a:20:{s:4:"name";s:21:"isMBSubstrCharEscaped";s:16:"start_line_index";i:563;s:17:"start_token_index";i:3315;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:118:"/**
	* isMBSubstrCharEscaped: checks if a char is escaped given its position based in the mb_substr php function
	*/";}s:25:"start_comments_line_index";i:560;s:26:"start_comments_token_index";i:3313;s:23:"end_comments_line_index";i:562;s:24:"end_comments_token_index";i:3313;s:22:"start_args_token_index";i:3322;s:20:"end_args_token_index";i:3327;s:9:"arguments";a:2:{s:4:"$str";N;s:6:"$index";N;}s:25:"start_brackets_line_index";i:563;s:26:"start_brackets_token_index";i:3329;s:23:"end_brackets_line_index";i:574;s:24:"end_brackets_token_index";i:3404;s:14:"end_line_index";i:574;s:15:"end_token_index";i:3404;}s:9:"isBadWord";a:20:{s:4:"name";s:9:"isBadWord";s:16:"start_line_index";i:579;s:17:"start_token_index";i:3408;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:59:"/**
	* isBadWord: verifies if a string is a bad word.
	*/";}s:25:"start_comments_line_index";i:576;s:26:"start_comments_token_index";i:3406;s:23:"end_comments_line_index";i:578;s:24:"end_comments_token_index";i:3406;s:22:"start_args_token_index";i:3415;s:20:"end_args_token_index";i:3417;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:579;s:26:"start_brackets_token_index";i:3419;s:23:"end_brackets_line_index";i:587;s:24:"end_brackets_token_index";i:3466;s:14:"end_line_index";i:587;s:15:"end_token_index";i:3466;}s:15:"replaceBadWords";a:20:{s:4:"name";s:15:"replaceBadWords";s:16:"start_line_index";i:592;s:17:"start_token_index";i:3470;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:64:"/**
	* replaceBadWords: replaces bad words with nicer ones
	*/";}s:25:"start_comments_line_index";i:589;s:26:"start_comments_token_index";i:3468;s:23:"end_comments_line_index";i:591;s:24:"end_comments_token_index";i:3468;s:22:"start_args_token_index";i:3477;s:20:"end_args_token_index";i:3479;s:9:"arguments";a:1:{s:7:"$string";N;}s:25:"start_brackets_line_index";i:592;s:26:"start_brackets_token_index";i:3481;s:23:"end_brackets_line_index";i:599;s:24:"end_brackets_token_index";i:3528;s:14:"end_line_index";i:599;s:15:"end_token_index";i:3528;}s:15:"replaceWebLinks";a:20:{s:4:"name";s:15:"replaceWebLinks";s:16:"start_line_index";i:604;s:17:"start_token_index";i:3532;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:48:"/**
	* replaceWebLinks: replaces web links
	*/";}s:25:"start_comments_line_index";i:601;s:26:"start_comments_token_index";i:3530;s:23:"end_comments_line_index";i:603;s:24:"end_comments_token_index";i:3530;s:22:"start_args_token_index";i:3539;s:20:"end_args_token_index";i:3548;s:9:"arguments";a:2:{s:7:"$string";N;s:12:"$replacement";s:2:"""";}s:25:"start_brackets_line_index";i:604;s:26:"start_brackets_token_index";i:3550;s:23:"end_brackets_line_index";i:637;s:24:"end_brackets_token_index";i:3786;s:14:"end_line_index";i:637;s:15:"end_token_index";i:3786;}s:14:"breakLongWords";a:20:{s:4:"name";s:14:"breakLongWords";s:16:"start_line_index";i:642;s:17:"start_token_index";i:3790;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:46:"/**
	* breakLongWords: breaks long words
	*/";}s:25:"start_comments_line_index";i:639;s:26:"start_comments_token_index";i:3788;s:23:"end_comments_line_index";i:641;s:24:"end_comments_token_index";i:3788;s:22:"start_args_token_index";i:3797;s:20:"end_args_token_index";i:3813;s:9:"arguments";a:3:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:642;s:26:"start_brackets_token_index";i:3815;s:23:"end_brackets_line_index";i:646;s:24:"end_brackets_token_index";i:3863;s:14:"end_line_index";i:646;s:15:"end_token_index";i:3863;}s:18:"breakLongTextWords";a:20:{s:4:"name";s:18:"breakLongTextWords";s:16:"start_line_index";i:651;s:17:"start_token_index";i:3867;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongTextWords: breaks long text words
	*/";}s:25:"start_comments_line_index";i:648;s:26:"start_comments_token_index";i:3865;s:23:"end_comments_line_index";i:650;s:24:"end_comments_token_index";i:3865;s:22:"start_args_token_index";i:3874;s:20:"end_args_token_index";i:3883;s:9:"arguments";a:2:{s:7:"$string";N;s:10:"$maxLength";s:2:"20";}s:25:"start_brackets_line_index";i:651;s:26:"start_brackets_token_index";i:3885;s:23:"end_brackets_line_index";i:669;s:24:"end_brackets_token_index";i:4029;s:14:"end_line_index";i:669;s:15:"end_token_index";i:4029;}s:18:"breakLongHtmlWords";a:20:{s:4:"name";s:18:"breakLongHtmlWords";s:16:"start_line_index";i:674;s:17:"start_token_index";i:4033;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:55:"/**
	* breakLongHtmlWords: breaks long html words
	*/";}s:25:"start_comments_line_index";i:671;s:26:"start_comments_token_index";i:4031;s:23:"end_comments_line_index";i:673;s:24:"end_comments_token_index";i:4031;s:22:"start_args_token_index";i:4040;s:20:"end_args_token_index";i:4056;s:9:"arguments";a:3:{s:4:"$str";N;s:10:"$maxLength";s:2:"20";s:5:"$char";s:3:"" "";}s:25:"start_brackets_line_index";i:674;s:26:"start_brackets_token_index";i:4057;s:23:"end_brackets_line_index";i:707;s:24:"end_brackets_token_index";i:4281;s:14:"end_line_index";i:707;s:15:"end_token_index";i:4281;}s:14:"sanitizeString";a:20:{s:4:"name";s:14:"sanitizeString";s:16:"start_line_index";i:712;s:17:"start_token_index";i:4285;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:29:"/**
	* sanitizeString: 
	*/";}s:25:"start_comments_line_index";i:709;s:26:"start_comments_token_index";i:4283;s:23:"end_comments_line_index";i:711;s:24:"end_comments_token_index";i:4283;s:22:"start_args_token_index";i:4292;s:20:"end_args_token_index";i:4301;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:712;s:26:"start_brackets_token_index";i:4303;s:23:"end_brackets_line_index";i:720;s:24:"end_brackets_token_index";i:4358;s:14:"end_line_index";i:720;s:15:"end_token_index";i:4358;}s:12:"sanitizeText";a:20:{s:4:"name";s:12:"sanitizeText";s:16:"start_line_index";i:725;s:17:"start_token_index";i:4362;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:12:"doc_comments";a:1:{i:0;s:27:"/**
	* sanitizeText: 
	*/";}s:25:"start_comments_line_index";i:722;s:26:"start_comments_token_index";i:4360;s:23:"end_comments_line_index";i:724;s:24:"end_comments_token_index";i:4360;s:22:"start_args_token_index";i:4369;s:20:"end_args_token_index";i:4378;s:9:"arguments";a:2:{s:7:"$string";N;s:5:"$html";s:5:"false";}s:25:"start_brackets_line_index";i:725;s:26:"start_brackets_token_index";i:4380;s:23:"end_brackets_line_index";i:744;s:24:"end_brackets_token_index";i:4549;s:14:"end_line_index";i:744;s:15:"end_token_index";i:4549;}}}}
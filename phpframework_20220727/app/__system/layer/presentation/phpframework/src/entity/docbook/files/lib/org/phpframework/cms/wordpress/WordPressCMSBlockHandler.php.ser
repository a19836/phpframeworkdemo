a:1:{s:24:"WordPressCMSBlockHandler";a:1:{s:7:"methods";a:5:{s:32:"convertContentsHtmlToPHPTemplate";a:15:{s:4:"name";s:32:"convertContentsHtmlToPHPTemplate";s:16:"start_line_index";i:35;s:17:"start_token_index";i:146;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:22:"start_args_token_index";i:153;s:20:"end_args_token_index";i:155;s:9:"arguments";a:1:{s:5:"$html";N;}s:25:"start_brackets_line_index";i:35;s:26:"start_brackets_token_index";i:157;s:23:"end_brackets_line_index";i:66;s:24:"end_brackets_token_index";i:524;s:14:"end_line_index";i:66;s:15:"end_token_index";i:524;}s:43:"addTemplateXMLRegionsAndParamsToPHPTemplate";a:20:{s:4:"name";s:43:"addTemplateXMLRegionsAndParamsToPHPTemplate";s:16:"start_line_index";i:69;s:17:"start_token_index";i:528;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:1:{i:0;s:60:"//replace all regions and params with correspondent xml code";}s:25:"start_comments_line_index";i:68;s:26:"start_comments_token_index";i:526;s:23:"end_comments_line_index";i:69;s:24:"end_comments_token_index";i:526;s:22:"start_args_token_index";i:535;s:20:"end_args_token_index";i:537;s:9:"arguments";a:1:{s:8:"$content";N;}s:25:"start_brackets_line_index";i:69;s:26:"start_brackets_token_index";i:539;s:23:"end_brackets_line_index";i:108;s:24:"end_brackets_token_index";i:893;s:14:"end_line_index";i:108;s:15:"end_token_index";i:893;}s:15:"getBlockContent";a:20:{s:4:"name";s:15:"getBlockContent";s:16:"start_line_index";i:127;s:17:"start_token_index";i:897;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:1117:"/*
	 * $block_id = "region_content_1"
	 * 
	 * $url_query = "/2020/10/21/hello-world/"
	 * $url_query = "/product/product-1/"
	 * 
	 * $options = array(
	 * 	"parse_wordpress_urls" => true/false, //If true, means that the system will replace all wordpress urls with the phpframework url
	 *	"parse_wordpress_relative_urls" => true/false, //If true, means that the system will replace all wordpress relative urls with the phpframework url
	 *	"allowed_wordpress_urls" => array("/some url regex/", "or a full url"), //regex for the urls that the system shouold leave alone
	 * )
	 * 
	 * if wordpress was previously called and the new wordpress template is different than the previous wordpress call, do a curl request. Do not call wordpress directly bc it was already initialized before with the template: $first_wordpress_theme_called. If we want to call the wordpress with a new template, we must do it now with a curl request, otherwise the data will not be trustable.
	 * Because of this reason we should call this method getBlockContent and not the getBlockContentDirectly directly.
	 * 
	 * returns an array
	 */";}s:25:"start_comments_line_index";i:110;s:26:"start_comments_token_index";i:895;s:23:"end_comments_line_index";i:126;s:24:"end_comments_token_index";i:895;s:22:"start_args_token_index";i:902;s:20:"end_args_token_index";i:910;s:9:"arguments";a:3:{s:9:"$block_id";N;s:10:"$url_query";N;s:8:"$options";N;}s:25:"start_brackets_line_index";i:127;s:26:"start_brackets_token_index";i:912;s:23:"end_brackets_line_index";i:296;s:24:"end_brackets_token_index";i:2152;s:14:"end_line_index";i:296;s:15:"end_token_index";i:2152;}s:23:"getBlockContentDirectly";a:20:{s:4:"name";s:23:"getBlockContentDirectly";s:16:"start_line_index";i:304;s:17:"start_token_index";i:2156;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:0;s:8:"comments";a:1:{i:0;s:470:"/*
	 * Try to avoid calling this method directly bc if wordpress was previously called and the new wordpress template is different than the previous wordpress call, the returned data will not be trustable, bc wordpress was already initialized wi tht first template and the data will be related with this template and not with the new template!
	 * Only call this method in the get_wordpress_content_array.php, bc of infinit loops with curl!
	 *
	 * returns an array
	 */";}s:25:"start_comments_line_index";i:298;s:26:"start_comments_token_index";i:2154;s:23:"end_comments_line_index";i:303;s:24:"end_comments_token_index";i:2154;s:22:"start_args_token_index";i:2161;s:20:"end_args_token_index";i:2173;s:9:"arguments";a:3:{s:9:"$block_id";N;s:10:"$url_query";N;s:8:"$options";s:4:"null";}s:25:"start_brackets_line_index";i:304;s:26:"start_brackets_token_index";i:2175;s:23:"end_brackets_line_index";i:454;s:24:"end_brackets_token_index";i:3395;s:14:"end_line_index";i:454;s:15:"end_token_index";i:3395;}s:18:"prepareRedirectUrl";a:20:{s:4:"name";s:18:"prepareRedirectUrl";s:16:"start_line_index";i:458;s:17:"start_token_index";i:3401;s:4:"type";s:6:"public";s:8:"abstract";b:0;s:6:"static";b:1;s:8:"comments";a:2:{i:0;s:56:"//called in the wordpress/wp-includes/pluggable.php file";i:1;s:317:"//leave prepareRedirectUrl here and DO NOT COPY IT to WordPressUrlsParser, bc the pluggable.php will only call this method if exists and the WordPressCMSBlockHandler class will only exists when called from the phpframework. If the user calls the wordpress directly, the prepareRedirectUrl method should not be called!";}s:25:"start_comments_line_index";i:456;s:26:"start_comments_token_index";i:3397;s:23:"end_comments_line_index";i:458;s:24:"end_comments_token_index";i:3399;s:22:"start_args_token_index";i:3408;s:20:"end_args_token_index";i:3414;s:9:"arguments";a:2:{s:10:"&$location";N;s:15:"$cookies_prefix";N;}s:25:"start_brackets_line_index";i:458;s:26:"start_brackets_token_index";i:3416;s:23:"end_brackets_line_index";i:490;s:24:"end_brackets_token_index";i:3667;s:14:"end_line_index";i:490;s:15:"end_token_index";i:3667;}}}}